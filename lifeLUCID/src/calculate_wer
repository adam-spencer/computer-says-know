#!/usr/bin/env python
"""
calculate_wer

Calculate the WER of a file output by `do_whisper` and either print the result
to stdout or write in JSON format to some output location.

Copyright Adam Spencer, 03/2023
"""
__author__ = 'Adam Spencer'

import argparse
import jiwer as jw
import json
from pathlib import Path

# This standardises strings for better comparison
TRANSFORM = jw.Compose( 
    [
      jw.ToLowerCase(),
      jw.ExpandCommonEnglishContractions(),
      jw.RemoveKaldiNonWords(),
      jw.RemoveWhiteSpace(replace_by_space=True),
      jw.RemovePunctuation(),
      jw.RemoveMultipleSpaces(),
      jw.Strip(),
      jw.ReduceToListOfListOfWords()
    ]
)

def get_file_wer(transcript_file:Path) -> dict:
  """
  Get WER from a transcript JSON file as returned by do_whisper.

  :param transcript_file: Path to transcript file.
  :returns: Dictionary representation of file with added WER.
  """
  with open(transcript_file) as file:
    data_dict = json.load(file)
  
  for idx, data in data_dict.items():
    wer = jw.wer(data['reference'], data['whisper']['text'],
           reference_transform=TRANSFORM, hypothesis_transform=TRANSFORM)
    data_dict[idx]['wer'] = wer

  return data_dict

def write_out(wer_dict:dict, /, out_path:Path=None, stdout:bool=False) -> None:
  """
  Write the WER output either to a specified file or to stdout.
  Output is in JSON format.

  :param wer_dict: WER dictionary as output by `get_file_wer()`
  :param out_path: Path to write output to.
  :param stdout: Write output to stdout rather than to a file.
  """
  if out_path is None and not stdout:
    raise ValueError('Must either supply a path or choose to print to stdout!')
  if stdout:
    print(json.dumps(wer_dict, indent=2))
  else:
    with open(out_path, 'w') as f:
      json.dump(out_path, f)

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('in_file', help='Input file')
  parser.add_argument('--output-dir','-o',
                      help='Output dir, if none is supplied then result is \
                      printed to stdout')
  args = parser.parse_args()

  in_file_path = Path(args.in_file)
  if save_output := args.output_dir is not None:
    out_path = Path(args.output_dir)

  if in_file_path.is_dir():
    if not save_output:
      raise ValueError('Must supply an output dir when input is dir')
    for file in in_file_path.iterdir():
      if not file.name.endswith('.json'):
        continue
      wer_dict = get_file_wer(file)
      write_path = out_path / file.name.replace('.json', '_wer.json')
      write_out(wer_dict, out_path=write_path)

  else:
    wer_dict = get_file_wer(in_file_path)
    if save_output:
      out_path = out_path / in_file_path.name.replace('.json', '_wer.json')
      write_out(wer_dict, out_path=out_path)
    else:
      write_out(wer_dict, stdout=True)

if __name__ == '__main__':
  main()
