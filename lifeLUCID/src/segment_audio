#!/usr/bin/env python
"""
segment_audio

Generate audio segments to some specification described in a JSON file.

Copyright Adam Spencer, 2023.
"""

__author__ = 'Adam Spencer'

import soundfile as sf
import json
import argparse
from pathlib import Path

from utils import vprint

def generate_segments(filename:Path, spec_file:Path, out_dir:Path, channel:int,
                      v:bool) -> None:
  """
  Generate audio segments given an audio file and segment metadata.

  :param filename: Path to input file.
  :param spec_file: Path to JSON segment metadata.
  :param channel: Which audio channel is being segmented.
  :param v: Verbose output.
  :returns: List containing segmented audio represented by Numpy arrays.
  """
  vprint(v, 'Loading metadata...')
  with open(spec_file) as f:
    seg_data = json.load(f)

  vprint(v, 'Loading audio...')
  sig, fs = sf.read(filename)
  sig = sig[:, channel]

  vprint(v, 'Beginning segmentation...')
  for seg_n, seg_meta in seg_data.items():
    slice_start = int(fs * seg_meta['start'])
    slice_end = int(fs * seg_meta['end'])
    outpath = out_dir / f'{int(seg_n):03d}.wav'
    sf.write(outpath, sig[slice_start:slice_end], fs)
  vprint(v, 'Done!')

def run_over_dir(audio_dir:Path, spec_dir:Path, out_dir:Path,
                 channel:int, v:bool) -> None:

  # IDEALLY THIS WOULD WORK, BUT IT DOESN'T!
  # Must find the matching spec and audio files, then generate a new output
  # subdirectory, then pass these into generate_segments() in a loop.
  # if channel == 0:
  #   spec_ext = 'Ac.json'
  # else:
  #   spec_ext = 'Bc.json'

  spec_ext = 'Ac.json'

  vprint(v, 'Looping over files...')
  if v:
    counter = 0
    total_files = len(list(audio_dir.glob('*')))

  for audio_file in audio_dir.iterdir():
    if v:
      counter += 1
      print(f'Progress: {counter} / {total_files}', end='\r')
    purename = audio_file.name.removesuffix('.wav')
    spec_file = spec_dir / f'{purename}_{spec_ext}'
    if spec_file.exists():
      out_subdir = out_dir / purename
      out_subdir.mkdir(exist_ok=True)
      generate_segments(audio_file, spec_file, out_subdir, channel, False)
    else:
      vprint(v, f"Couldn't find a spec file for {purename}!")

def main() -> None:
  parser = argparse.ArgumentParser()
  parser.add_argument('audio_file', help='Input audio file/directory')
  parser.add_argument('spec_file',
                      help='Input JSON file/directory containing segment \
                      specification')
  parser.add_argument('out_dir', help='Output directory')
  parser.add_argument('--channel', '-c', choices=[0,1], type=int,
                      help='Specify channel, 0 = L, 1 = R',
                      default=0)
  parser.add_argument('--dir-mode', '-d', action='store_true',
                      help='Activate directory mode')
  parser.add_argument('--verbose', '-v', action='store_true',
                      help='Activate verbose output')
  args = parser.parse_args()

  audio_file = Path(args.audio_file)
  spec_file = Path(args.spec_file)
  out_dir = Path(args.out_dir)

  # This is mildly janky; there must be a better way!
  if out_dir.is_dir():
    if args.dir_mode and audio_file.is_dir() and spec_file.is_dir():
      run_over_dir(audio_file, spec_file, out_dir, args.channel, args.verbose)
      return
    elif not args.dir_mode and not audio_file.is_dir() and not spec_file.is_dir():
      generate_segments(audio_file, spec_file, out_dir, args.channel, args.verbose)
      return
  raise ValueError('Incorrect path specification!')

if __name__ == '__main__':
  main()
